package utils

import (
	"youfun/shipyard/internal/config"
	"fmt"
	"log"
	"os"
	"path/filepath"
)

// GetAppNameFromConfig reads the shipyard.toml file and returns the configured app name.
func GetAppNameFromConfig() (string, error) {
	return GetAppNameFromConfigPath(config.ConfigPath)
}

// GetAppNameFromConfigPath reads a specific config file and returns the configured app name.
func GetAppNameFromConfigPath(configPath string) (string, error) {
	if configPath == "" {
		configPath = "shipyard.toml"
	}

	cfg, err := config.ReadConfigFile(configPath)
	if err != nil {
		return "", fmt.Errorf("failed to read or parse %s: %w. Please ensure the file exists and is correctly formatted", configPath, err)
	}

	if cfg.App == "" {
		return "", fmt.Errorf("'app' configuration not found in %s", configPath)
	}

	return cfg.App, nil
}

// ResolveAppNameFromConfig reads the app name from shipyard.toml.
// It checks if the config file exists and returns the app name.
func ResolveAppNameFromConfig() string {
	configPath := config.ConfigPath

	// Check if config file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		log.Fatalf("Error: Config file '%s' not found. Please run in the project directory, or use --app to specify the application name.", configPath)
	}

	projConf, err := config.ReadConfigFile(configPath)
	if err != nil {
		log.Fatalf("Failed to read config file: %v", err)
	}

	if projConf.App == "" {
		log.Fatalf("Error: Could not determine application name. Please set 'app' in %s or use the --app flag.", configPath)
	}
	log.Printf("Using application name: '%s'", projConf.App)
	return projConf.App
}

// HandleShipyardToml ensures shipyard.toml exists and returns its config and app name.
// If appNameFlag is provided, it overrides the config file value.
func HandleShipyardToml(appNameFlag string) (config.Config, string) {
	configPath := config.ConfigPath

	// Check if config file exists, create if not
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		log.Printf("File '%s' does not exist, creating...", configPath)
		if err := CreateDefaultShipyardToml(); err != nil {
			log.Fatalf("❌ Failed to create '%s': %v", configPath, err)
		}
		log.Printf("✅ Successfully created '%s'. Please check the file content and modify as needed.", configPath)
	} else {
		log.Printf("File '%s' already exists, reading...", configPath)
	}

	// Read the config file
	projConf, err := config.ReadConfigFile(configPath)
	if err != nil {
		log.Fatalf("Failed to parse '%s': %v", configPath, err)
	}

	// Determine final app name (flag > toml)
	appName := projConf.App
	if appNameFlag != "" {
		appName = appNameFlag
	}

	if appName == "" {
		log.Fatalf("Error: Could not determine application name. Please set 'app' in %s or use the --app flag.", configPath)
	}
	log.Printf("Using application name: '%s'", appName)
	return *projConf, appName
}

// CreateDefaultTomlIfNotExist checks for shipyard.toml and creates it if it doesn't exist.
// It returns true if the file was created.
func CreateDefaultTomlIfNotExist() (bool, error) {
	tomlPath := config.ConfigPath
	if _, err := os.Stat(tomlPath); os.IsNotExist(err) {
		log.Printf("File '%s' does not exist, creating...", tomlPath)
		if err := CreateDefaultShipyardToml(); err != nil {
			return false, err
		}
		return true, nil
	} else if err != nil {
		return false, fmt.Errorf("failed to check file '%s': %w", tomlPath, err)
	}
	return false, nil // File already existed
}

// CreateDefaultShipyardToml creates a default shipyard.toml file with template content.
func CreateDefaultShipyardToml() error {
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current working directory: %w", err)
	}
	appName := filepath.Base(cwd)

	content := fmt.Sprintf(`# shipyard.toml configuration file (fly.toml-like format)
# Generated by Shipyard CLI

app = '%s'

# Supports multiple domains
domains = ["example.com", "www.example.com"]

# (Optional) Specify primary domain, defaults to domains[0] if not set
# primary_domain = "example.com"

keep_releases = 3


# [env] defines non-sensitive application environment variables
# bool and number types do not need quotes, string types do
[env]
  PHX_SERVER=true
  PHX_HOST = "example.com"


# [hooks] defines commands to execute at specific stages of the deployment lifecycle.
# For example, running database migrations before traffic switch.
[hooks]
  # migrate hook runs after new version health check passes, before traffic switch.
  # If migrate hook fails, deployment is aborted.
  # type: "shell" or "eval" (eval only for Elixir/Phoenix apps, runs code inside the app)
  # command: command or Elixir code to execute
  [[hooks.migrate]]
    name = "migrate_database"
    type = "shell"
    command = "bin/migrate"

`, appName)

	return os.WriteFile(config.ConfigPath, []byte(content), 0644)
}
