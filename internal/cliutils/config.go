package cliutils

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"youfun/shipyard/internal/config"

	"github.com/BurntSushi/toml"
)

// GetAppNameFromConfig reads the shipyard.toml file and returns the configured app name.
func GetAppNameFromConfig() (string, error) {
	return GetAppNameFromConfigPath(config.ConfigPath)
}

// GetAppNameFromConfigPath reads a specific config file and returns the configured app name.
func GetAppNameFromConfigPath(configPath string) (string, error) {
	if configPath == "" {
		configPath = "shipyard.toml"
	}

	cfg, err := config.ReadConfigFile(configPath)
	if err != nil {
		return "", fmt.Errorf("failed to read or parse %s: %w. Please ensure the file exists and is valid", configPath, err)
	}

	if cfg.App == "" {
		return "", fmt.Errorf("'app' not found in %s", configPath)
	}

	return cfg.App, nil
}

// ResolveAppNameFromConfig reads the app name from shipyard.toml.
// It checks if the config file exists and returns the app name.
func ResolveAppNameFromConfig() string {
	configPath := config.ConfigPath

	// Check if config file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		log.Fatalf("Error: configuration file '%s' not found. Please run in the project directory or specify the application name with --app. or use launch command", configPath)
	}

	projConf, err := config.ReadConfigFile(configPath)
	if err != nil {
		log.Fatalf("Failed to read configuration file: %v", err)
	}

	if projConf.App == "" {
		log.Fatalf("Error: could not determine application name. Please set 'app' in %s or use the --app flag.", configPath)
	}
	log.Printf("Using application name: '%s'", projConf.App)
	return projConf.App
}

// HandleShipyardToml ensures shipyard.toml exists and returns its config and app name.
// If appNameFlag is provided, it overrides the config file value.
func HandleShipyardToml(appNameFlag string) (config.Config, string) {
	configPath := config.ConfigPath

	// Check if config file exists, create if not
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		log.Printf("'%s' not found, creating...", configPath)
		if err := CreateDefaultShipyardToml(); err != nil {
			log.Fatalf("❌ Failed to create '%s': %v", configPath, err)
		}
		log.Printf("✅ Successfully created '%s'. Please review and modify as needed.", configPath)
	} else {
		log.Printf("'%s' exists, reading...", configPath)
	}

	// Read the config file
	var projConf config.Config
	if _, err := toml.DecodeFile(configPath, &projConf); err != nil {
		log.Fatalf("Failed to parse '%s': %v", configPath, err)
	}

	// Determine final app name (flag > toml)
	appName := projConf.App
	if appNameFlag != "" {
		appName = appNameFlag
	}

	if appName == "" {
		log.Fatalf("Error: could not determine application name. Please set 'app' in %s or use the --app flag.", configPath)
	}
	log.Printf("Using application name: '%s'", appName)
	return projConf, appName
}

// CreateDefaultTomlIfNotExist checks for shipyard.toml and creates it if it doesn't exist.
// It returns true if the file was created.
func CreateDefaultTomlIfNotExist() (bool, error) {
	tomlPath := config.ConfigPath
	if _, err := os.Stat(tomlPath); os.IsNotExist(err) {
		log.Printf("'%s' not found, creating...", tomlPath)
		if err := CreateDefaultShipyardToml(); err != nil {
			return false, err
		}
		return true, nil
	} else if err != nil {
		return false, fmt.Errorf("failed to check '%s': %w", tomlPath, err)
	}
	return false, nil // File already existed
}

// CreateDefaultShipyardToml creates a default shipyard.toml file with template content.
func CreateDefaultShipyardToml() error {
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("unable to get current working directory: %w", err)
	}
	appName := filepath.Base(cwd)

	content := fmt.Sprintf(`# shipyard.toml configuration file (similar to fly.toml format)
# Generated by the Shipyard CLI

app = '%s'

# Supports multiple domains
domains = ["example.com", "www.example.com"]

# (optional) specify the primary domain; if not set, defaults to domains[0]
# primary_domain = "example.com"

keep_releases = 3


# [env] used to define non-sensitive environment variables for the app
# Booleans and numbers do not need quotes; strings require quotes
[env]
  PHX_SERVER=true
  PHX_HOST = "example.com"


# [hooks] used to define commands executed at specific deployment stages.
# For example, run database migrations before switching traffic.
[hooks]
  # The migrate hook runs after the new release passes health checks and before traffic switch.
  # If the migrate hook fails, the deployment will be aborted.
  # type: "shell" or "eval" (eval is only applicable to Elixir/Phoenix apps and runs code inside the app)
  # command: the command to run or Elixir code to execute
  [[hooks.migrate]]
    name = "migrate_database"
    type = "shell"
    command = "bin/migrate"

`, appName)

	return os.WriteFile(config.ConfigPath, []byte(content), 0644)
}
